This document contains all the globals, classes, functions and their apis from icebreaks.py.


### GLOBALS ###

*** DictStrSet = Dict[str, set]
    DictStrSet is a type aliases because the type hint Dict[str, set] occurs a lot in IceBrakes.


### CLASSES ### 

States
This is a bit of a catchall class it handles global state bools, as well as namespace scoping tools.
    
    *PROPERTIES*

    errors: bool = False
        States.errors is used to track whether the lint failed or passed. And helps with the error codes too.

    indent: int = 0
        Tracks the current indentation level of the file.

    old_indent: int = -999
        The previous indentation level which is needed for changing scopes.

    names_in_scope = [('root', 0)]
        The list tracks the current scope relative to the root of the file and is how we build the custom dict keys that implement scope tracking.

    dir_mode: bool = False           # NOT WRITTEN YET
        This bool tracks wether we are parsing a single file or a directory. 


    *METHODS*

    update_indent(self, indent: int) -> None
        This method updates the indent level and when the indent level
        goes down it leaves the current scope.


### FUNCTIONS ###

file_or_dir(path: str) -> None       # RENAME
    Takes an input string and if it's a dir recursively lints it,
    and if it's a file lints it, and otherwise prints an error message.
    
    This one function is all we needed for dir support.


icebrakes(filepath: str, dir_mode: bool=False) -> int

    This function takes a python file and lints it. Returns an integer exit code.


get_names_from_file(file: List[str], states: States) -> Tuple[dict, dict] 

    This function parses a python file for any names declared and builds two dictionaries.
    One dict is for all_vars in the file and one dict is only for constants. Constants are 
    defined as vars declared on a line ending in #$. 

    There is a subfunction called get_names_from_line() which is run on nonempty/noncomment
    lines of the file and actually grabs the names using paren_parse() and equal_sign_parse().

    When paren_parse() returns a nonempty string get_names_from_line() adds a new entry to
    States.names_in_scope to keep track of the new namespace we are in.

    Once per line of the file get_names_from_file() also calls States.update_indent() to change
    the current, and past indent vars and to leave the scope when indent decreases.


name_gen(name: str, states: States) -> str

    Create unique keys for the all_vars/constants dicts using names_in_scope to create a key.


name_split(name: str) -> str

    Gets all chars to the right of the last period in a string.


paren_parse(line: str) -> str

    Searches a line for one of these openers ['async def ', 'def' , 'class '] 
    and if an opener is found then the string between the opener and "(" is returned.

    This captures var names on lines like: 
    def name():
    class name():
    async def name():


equal_sign_parse equal_sign_parse(line: str) -> str

    This method parses a string for any single equal sign
    and gets the first name before the equal sign. 
    
    I also added support for other kinds of assignment like +=, *=, /=. The
    dreaded and ugly := operator is not yet supported because it's weird.

    There is currently a BUG where IceBrakes doesn't know about strings yet.
    
        'x = 45' 

    Would create the name 'x which is not desirable. This will be addressed urgently.


cross_reference(constants: DictStrSet, all_vars: DictStrSet, states: States) -> None:

    Once you have the constants and all_vars for a given python file you can cross reference them to see if any constants are overwritten illegally and inform the users. This is the main interface our users will interact with.


white_space_parse(file: List[str]) -> int

    Takes a file and calculates how many spaces that file uses to indent by parsing
    the first 100 indented lines of the file.

    We are considering tabs as whitespace but I haven't written the code to calculate how many
    tabs a user is using for one indent. I mostly don't care about tabs to be honest so while
    this will only be a few lines of code, it's not very urgent.

    IceBrakes is not intended to replace your regular linting and if there are major white space
    errors IceBrakes may have unexpected output.


### EXIT CODES ###

    0: Lint passed
    1: Lint failed.

    Exit code 2 was relegated for directory support.
    2: No immutables declared.

    It turned out to be pretty complicated adding exit code three because
    some lines might trigger EC3 and some might trigger EC1. So now any failures
    result in EC1 and EC2 is still used for when a lint isn't run at all.
    3: Immutable declared on a line but not defined.
